# 为什么我们需要异步?



大家都很喜爱Rust让我们编写出又快又安全的程序的方式。但是为什么要编写异步的代码呢？

异步代码让我们能够在同一操作系统的线程上并发地运行多个任务。一个有代表性的例子就是，如果你想要同时下载两个网页，就要把工作分配给两个不同的线程，就像下面这样：

```rust,ignore
{{#include ../../examples/01_02_why_async/src/lib.rs:get_two_sites}}
```

确实这样做在很多应用场景下都是行得通的——毕竟，线程设计出来就是为了做这个的：一次运行多个不同人物。然而局限性也同样存在：在不同的线程间切换或共享数据会带来很大的开销，即便一个线程不做任何事，它也会消耗大量宝贵的系统资源。而这就是要通过异步代码的设计来消除的开销。我们可以通过Rust的`async`/`.await`关键字来重写上面的函数，以在不创建多个线程的条件下同时运行多个任务：

```rust,ignore
{{#include ../../examples/01_02_why_async/src/lib.rs:get_two_sites_async}}
```

总的来说，与相应的线程实现相比，异步应用程序有可能更快，且使用更少的资源。但是还是存在开销，线程是受操作系统原生支持的，使用它不需要其他特殊的编程模型——任何函数都可以创建一个线程，而调用这些函数就跟调用普通的函数一样简单。而一部的函数则需要编程语言或库的额外支持。

在Rust中，`async fn`能够创建一个返回`Future`的异步函数。为了执行其函数体，必须运行返回的`Future`来完成。

别忘了传统的多线程应用也可以是非常高效的，而由于Rust的低内存占用和可预测性，即便不使用`async`也可以做很多事。由于异步编程模型而增加的复杂性并不总是值得的，因此考虑一下单纯地采用多线程模型是不是更好也是很重要的。